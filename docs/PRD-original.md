這是一份針對 **Web 端 3D 轉 2D 視角錯位解謎遊戲** 的產品需求文件（PRD）。

這份文件的核心目標是定義**「引擎邏輯」**，即如何讓程式碼理解「視覺上的連結等於物理上的連結」。

---

# 產品需求文件 (PRD)：Project Ortho-Engine (Web Demo)

| 項目 | 內容 |
| --- | --- |
| **文件版本** | v1.0 |
| **專案類型** | WebGL 益智平台遊戲 Demo |
| **核心目標** | 驗證「正交視角旋轉」與「空間壓縮碰撞」的核心玩法機制 |
| **目標平台** | PC Browser (Chrome/Firefox/Edge) |

---

## 1. 產品概述 (Overview)

本專案旨在開發一個基於 Web 的遊戲引擎 Demo。玩家在一個看由 3D 體素（Voxels）構成的世界中，控制一名 2D 角色。
**核心體驗：** 玩家無法在 3D 空間中前後移動，只能透過**旋轉世界 90 度**，利用正交投影（Orthographic Projection）的特性，消除空間深度，將原本不相連的道路在 2D 平面上「視覺接合」，從而到達終點。

---

## 2. 核心遊戲機制 (Core Mechanics)

### 2.1 角色移動 (Character Controller)

角色被視為一個 2D 平面上的物體，其物理運算僅限於當前視角的 X/Y 軸（或 Z/Y 軸）。

* **基本動作：** 左跑、右跑、跳躍、閒置。
* **物理規則：**
* **重力：** 始終向下（Y 軸負方向）。
* **碰撞（Collision）：** 角色與世界中的方塊進行 AABB（軸對齊邊界框）碰撞檢測。
* **限制：** 角色永遠不會有「深度」移動（即不能走出螢幕平面）。



### 2.2 視角旋轉與重構 (Perspective Rotation & Remapping)

這是本引擎最複雜也最重要的部分。

* **四個視角狀態 (View States)：**
* Front (0°)
* Right (90°)
* Back (180°)
* Left (270°)


* **旋轉邏輯：**
1. 玩家觸發旋轉。
2. **輸入鎖定：** 旋轉動畫期間（約 0.5秒），禁止角色移動。
3. **世界旋轉：** 攝影機圍繞場景中心旋轉 90 度。
4. **深度扁平化 (Depth Flattening)：**
* 當旋轉結束時，系統必須忽略當前視角的「深度軸」。
* *例如：從 Front 轉到 Right，原本的 Z 軸深度被忽略，原本遠處的平台現在與近處的平台在 X 軸座標上視為同一平面。*


5. **位置校正 (Snapping)：** 旋轉完成瞬間，若角色腳下無支撐物，但在新視角下「視覺上」下方有平台，角色應被判定為站在該平台上。



### 2.3 碰撞檢測邏輯 (The "Magic" Collision)

引擎不應使用真實的 3D 物理引擎（如 Cannon.js 的預設模式），而是使用**自定義的投影碰撞**。

* **邏輯公式：**
* 假設角色在座標 。
* **在 Front 視角：** 檢查所有方塊，只要方塊的  與角色重疊（忽略  值的差異），即視為碰撞（實體）。
* **在 Right 視角：** 檢查所有方塊，只要方塊的  與角色重疊（忽略  值的差異），即視為碰撞。


* **例外處理：** 為了避免穿模，當前景方塊擋住角色時，角色應被渲染在前景之上（透過渲染層級 Layer 控制），或者將遮擋物半透明化。

---

## 3. 操作控制 (Controls)

我們專注於 PC 網頁端操作。

| 動作 | 鍵盤輸入 | 邏輯行為 |
| --- | --- | --- |
| **向左移動** | A / Left Arrow | 角色的 X 軸 (或當前橫軸) 速度 -1 |
| **向右移動** | D / Right Arrow | 角色的 X 軸 (或當前橫軸) 速度 +1 |
| **跳躍** | Space / W / Up | 給予 Y 軸正向脈衝 |
| **左旋轉** | Q | 攝影機逆時針旋轉 90 度 |
| **右旋轉** | E | 攝影機順時針旋轉 90 度 |

---

## 4. 攝影機系統 (Camera System)

* **類型：** `OrthographicCamera` (Three.js)。
* **參數設定：**
* **Zoom：** 固定，不允許玩家縮放（避免破壞像素對齊感）。
* **位置：** 跟隨角色 (Camera Follow)，帶有輕微的平滑延遲 (Lerp)，讓移動更自然。


* **旋轉過渡：** 使用 `Tween` 動畫庫（如 GSAP）進行旋轉插值，確保從 0° 到 90° 是平滑曲線，而不是瞬間跳轉。

---

## 5. 關卡與數據結構 (Level Data Structure)

為了方便引擎讀取，不使用傳統 3D 模型檔案（.obj/.gltf），建議使用 **3D 陣列 (Grid System)** 來定義關卡。

* **數據格式 (JSON 範例)：**
```json
{
  "levelName": "Demo_01",
  "gridSize": [10, 20, 10],
  "voxels": [
    { "x": 0, "y": 0, "z": 0, "type": "grass" },
    { "x": 1, "y": 0, "z": 0, "type": "grass" },
    { "x": 5, "y": 2, "z": 5, "type": "stone_platform" } // 這個平台在 Front 視角看似與上面斷開，轉視角後可能相連
  ],
  "startPosition": { "x": 0, "y": 1, "z": 0 }
}

```


* **優勢：** 這種數據結構非常容易進行上述的「投影碰撞計算」。

---

## 6. 使用者介面 (UI / HUD)

由於是 Demo，UI 保持極簡，重點在於 Debug 資訊。

### 6.1 抬頭顯示器 (HUD)

* **旋轉提示：** 螢幕左下/右下顯示 `[Q]` `[E]` 按鈕圖示。
* **收集品計數：** (可選) 0/3 立方體。

### 6.2 開發者除錯面板 (Debug Panel - 關鍵)

這對開發引擎至關重要，必須包含：

* **Current View:** 顯示當前視角 (Front/Right/Back/Left)。
* **Player Coordinates:** 顯示角色整數座標 。
* **Raycast Status:** 顯示當前腳下是否有偵測到「視覺地面」。
* **Force Rotate:** 強制旋轉按鈕（防止卡死）。

---

## 7. 驗收標準 (MVP Success Metrics)

Demo 完成後，必須能通過以下測試才算合格：

1. **無限循環測試：** 角色能在 4 個方塊組成的口字型路徑中，透過不斷旋轉視角無限跑圈。
2. **斷路測試：** 角色面前有一個由深處方塊組成的斷路，不旋轉時跳不過去（會掉落），旋轉後能平穩走過去。
3. **無穿牆測試：** 旋轉時，角色不會被卡在牆壁內部或掉出世界邊界。

---

### 下一步建議

這份文件確認後，開發的第一步建議是：
**不要先做角色，先做「世界渲染」與「旋轉矩陣」。**
先用 Three.js 把那一堆方塊畫出來，並實現按 Q/E 能正確且平滑地旋轉 90 度。



---



這是一個非常明智的決定。開發這種依賴「空間結構」的解謎遊戲，如果用程式碼手寫陣列（Hardcoding arrays）來設計關卡會非常痛苦且效率低落。

**內建地圖編輯器（Level Editor）** 不僅是開發工具，甚至可以成為遊戲未來的核心功能（讓玩家分享關卡）。

以下是更新後的 **v1.1 版 PRD**，加入了完整的地圖編輯器模組。

---

# 產品需求文件 (PRD): Project Ortho-Engine (含地圖編輯器)

| 項目 | 內容 |
| --- | --- |
| **文件版本** | v1.1 (新增地圖編輯功能) |
| **專案類型** | WebGL 益智平台遊戲 + 關卡編輯器 |
| **核心目標** | 驗證 4-Wall 視角錯位玩法，並實現「所見即所得」的關卡建構流程 |
| **目標平台** | PC Browser (Chrome/Firefox/Edge) |

---

## 1. 系統架構：雙模式切換 (Dual-Mode System)

為了兼顧遊玩與編輯，引擎必須具備兩個互斥的狀態（State）。

| 模式 | **遊玩模式 (Play Mode)** | **編輯模式 (Edit Mode)** |
| --- | --- | --- |
| **核心目標** | 解謎、通關 | 建構、修改地形 |
| **攝影機行為** | **正交 (Orthographic)**<br>

<br>鎖定 4 個 90度視角，跟隨角色。 | **透視/正交皆可 (Orbit)**<br>

<br>允許自由旋轉、縮放，以便放置被遮擋的方塊。 |
| **物理運算** | **開啟** (重力、碰撞有效) | **暫停** (角色凍結或重置) |
| **輸入控制** | 控制角色 (WASD/跳躍) | 控制游標 (滑鼠點擊放置/移除) |

---

## 2. 核心遊戲機制 (Play Mode)

*(此部分保持 v1.0 設定，為節省篇幅僅列出關鍵點)*

* **視角限制：** 堅持 **4-Wall** 機制 (Front, Right, Back, Left)。
* **錯位連結：** 視覺上相連即物理相連。
* **角色能力：** 移動、跳躍 (無攀爬)。

---

## 3. 地圖編輯器規格 (Level Editor Specs)

這是本次更新的重點。編輯器必須能在 Web 端直接運行。

### 3.1 網格系統 (Voxel Grid System)

* **基礎單位：** 世界被劃分為  的隱形網格。
* **游標 (Ghost Cursor)：**
* 當滑鼠在畫面上移動時，顯示一個半透明的「幽靈方塊」。
* 幽靈方塊必須**吸附 (Snap)** 到最近的整數座標 。


* **射線檢測 (Raycasting)：**
* 使用 Three.js 的 `Raycaster` 從滑鼠位置發射射線。
* **放置邏輯：** 射線擊中現有方塊的面  在該面的法線方向 (Normal) 延伸一格顯示幽靈方塊。
* **移除邏輯：** 射線擊中現有方塊  高亮顯示該方塊（紅色外框）。



### 3.2 筆刷與方塊類型 (Block Palette)

編輯器需要一個簡單的 UI 面板來選擇當前筆刷：

1. **Solid Block (一般方塊):** 標準地形，可阻擋角色。
2. **Platform (單向平台):** (選用) 可從下方跳穿。
3. **Spawn Point (出生點):** 設定 Gomeze 的起始位置（全圖只能有一個，放置新的會覆蓋舊的）。
4. **Goal (終點):** 觸碰即勝利。
5. **Eraser (橡皮擦):** 點擊移除方塊。

### 3.3 數據序列化 (Serialization)

編輯器必須能將當前的 3D 世界轉換成 JSON，反之亦然。

* **Export (存檔):** 遍歷場景中所有方塊，生成 JSON 字串並輸出到 Console 或下載為 `.json` 檔。
* **Import (讀檔):** 讀取 JSON，清空場景，重新生成方塊。

**JSON 結構優化版：**

```json
{
  "meta": {
    "version": "1.1",
    "author": "User",
    "created_at": "2023-10-27"
  },
  "level_data": {
    "grid_size": [20, 20, 20],
    "spawn_point": [0, 5, 0],
    "blocks": [
       // 為了縮減檔案大小，建議只存座標，不存多餘屬性
       [0, 0, 0, 1], // [x, y, z, typeID]
       [1, 0, 0, 1],
       [0, 1, 0, 2] 
    ]
  }
}

```

---

## 4. 操作控制 (Controls Update)

新增編輯模式的操作。

| 動作 | 鍵盤/滑鼠輸入 | 邏輯行為 |
| --- | --- | --- |
| **切換模式** | Tab | 在 Play / Edit 模式間切換 |
| **(Edit) 旋轉視角** | 滑鼠右鍵拖曳 | 自由旋轉攝影機 (OrbitControls) |
| **(Edit) 平移視角** | 滑鼠中鍵 / Shift+左鍵 | 平移攝影機 (Pan) |
| **(Edit) 放置方塊** | 滑鼠左鍵 (點擊) | 在游標處生成實體方塊 |
| **(Edit) 移除方塊** | Alt + 左鍵 (或切換橡皮擦) | 移除目標方塊 |
| **(Edit) 選擇筆刷** | 數字鍵 1-5 | 1:方塊, 2:終點, 3:出生點... |
| **(Global) 輸出地圖** | P (Print) | 將地圖 JSON 輸出至 Console |

---

## 5. 使用者介面 (UI / HUD)

界面需要分為兩層。

### 5.1 Play Mode UI

* (保持簡潔) 僅顯示旋轉提示。

### 5.2 Edit Mode UI (側邊欄或頂部欄)

當按下 Tab 進入編輯模式時，顯示此 UI：

* **Palette:** 一排按鈕顯示當前選中的方塊類型（高亮）。
* **Actions:**
* `[Clear All]` 清空地圖。
* `[Save to Console]` 輸出 JSON。
* `[Load from Text]` 彈出對話框輸入 JSON 字串並載入。


* **Gizmo:** 畫面右上角顯示 3D 座標軸 (X, Y, Z)，幫助辨識方向。

---

## 6. 技術實作關鍵路徑 (Critical Path)

為了確保開發順利，建議的實作順序如下：

1. **Step 1: 基礎網格與游標 (The Grid)**
* 實作 Edit Mode 的自由攝影機。
* 實作滑鼠 Raycasting，讓一個紅色的「幽靈方塊」能準確吸附在虛擬網格上。


2. **Step 2: 方塊增刪 (CRUD)**
* 點擊左鍵 -> `scene.add(mesh)` 並存入資料陣列。
* 點擊右鍵 -> `scene.remove(mesh)` 並從陣列移除。


3. **Step 3: 模式切換 (The Switch)**
* 按下 Tab 鍵：
* **To Play:** 鎖定攝影機角度，生成主角在 Spawn Point，開啟物理 Tick。
* **To Edit:** 移除主角，解鎖攝影機，停止物理 Tick。




4. **Step 4: 整合 (Integration)**
* 在 Edit Mode 蓋一座斷橋 -> 切換 Play Mode -> 旋轉視角 -> 走過去。



---

### 給開發者的建議 (Q&A)

**Q: 編輯模式下，方塊重疊怎麼辦？**

* **A:** 程式邏輯必須禁止在同一個  座標重複放置方塊。每次放置前檢查 `blocks` 陣列是否該座標已有資料。

**Q: 地圖太大了怎麼辦？**

* **A:** MVP 階段建議鎖死地圖邊界，例如 。這剛好是一個 Chunk 的大小，效能最好控制。

**Q: 視覺上如何區分現在是 2D 還是 3D？**

* **A:** 這很重要。
* **Play Mode (2D感):** 使用 `OrthographicCamera`，背景設為單色（Flat Color）。
* **Edit Mode (3D感):** 使用 `PerspectiveCamera` (透視相機) 或者保持正交但顯示「網格線 (GridHelper)」，背景可以變暗，暗示現在是後台模式。



這份 PRD 是否符合你對於「引擎建構」的想像？如果沒問題，你就可以開始架設 Three.js 的環境了！
你需要我提供 **「如何計算投影碰撞」** 的虛擬碼（Pseudo-code）邏輯嗎？這是整個引擎最難寫的部分。
